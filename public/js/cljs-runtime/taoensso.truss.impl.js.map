{"version":3,"sources":["taoensso/truss/impl.cljc"],"mappings":";AAUA,AAWS,wCAAA,xCAAeA,wFAAaC;AAA5B,AAA+B,qBAAWC,bAAwBD;;AAU3E,0CAAA,1CAAME,4FAEHC,EAAEC;AAFL,AAIW,uDAAA,hDAACC,qDAAQ,AAAUF,UAAEC;;AAEhC,oCAAA,pCAAME,gFAAmCC,KAAKC;AAA9C,AAAoD,OAACC,+CAAO,WAAKC,EAAEC;AAAP,AAAW,oBAAI,CAACJ,qCAAAA,0CAAAA,PAAKI,sBAAAA;AAAV;;AAAmB,yBAAA,lBAACC;;GAAvC,KAA6DJ;;AACjH,6BAAA,7BAAMK,kEAAmCN,KAAKC;AAA9C,AAAoD,OAACC,+CAAO,WAAKC,EAAEC;AAAP,AAAW,oBAAI,CAACJ,qCAAAA,0CAAAA,PAAKI,sBAAAA;AAAIH;;AAAK,yBAAA,lBAACI;;GAAiBJ,KAAKA;;AACjH,4BAAA,5BAAMM,gEAAmCP,KAAKC;AAA9C,AAAoD,OAACC,+CAAO,WAAKC,EAAEC;AAAP,AAAW,IAAAI,qBAAa,CAACR,qCAAAA,0CAAAA,PAAKI,sBAAAA;AAAnB,AAAA,oBAAAI;AAAA,AAAA,QAAAA,JAAWC;AAAX,AAAwB,OAACJ,kBAAQI;;AAAjC;;GAAnB,KAA6DR;;AACjH,AAAA,iCAAA,yCAAAS,1EAAME;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,6DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,6DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,+DAAA,/DAAMD,0EACFE,EAAEC,EAAEC;AADR,AACiB,GAAA,GAAQ,MAAA,LAAMA;AAAG,OAACC,8CAAMH,EAAEC,EAAEC;;AAAGF;;;;AADhD,CAAA,+DAAA,/DAAMF,0EAEFE,EAAMI;AAFV,AAEiB,OAACC,oBAAWP,+BAAWE,EAAEI;;;AAF1C,CAAA,yDAAA,zDAAMN;;AAAN,AAIA,iCAAA,jCAAMQ,0EAAY3B;AAAlB,AAAqB,GAAI,AAAC4B,qBAAK5B;AAAGA;;AAAE,OAAC6B,cAAI7B;;;AACzC,qCAAA,rCAAM8B,kFAAoCC,GAAGV;AAA7C,AAAgD,yCAAA,WAAAW,7CAAC1B;AAAD,AAAU,UAAA,oEAAA,nEAAO,8CAAA0B,9CAACC,4CAAIZ;GAAMU;;AAC5E,6BAAA,7BAAMG,kEAAoCH,GAAGV;AAA7C,AAAgD,IAAAc,oBAAK,CAAI,AAACC,gBAAMf,OAAG,AAACe,gBAAML;AAA1B,AAAA,GAAAI;AAA+B,yCAAA,WAAAE,7CAAC/B;AAAD,AAAU,mCAAA+B,5BAACC,0BAAUjB;GAAKU;;AAAzDI;;;AAChD,iCAAA,jCAAMI,0EAAoCR,GAAGV;AAA7C,AAAgD,IAAAc,oBAAK,CAAI,AAACC,gBAAMf,MAAG,AAACe,gBAAML;AAA1B,AAAA,GAAAI;AAA+B,yCAAA,WAAAK,7CAAClC;AAAD,AAAU,mCAAAkC,5BAACF,0BAAUjB;GAAKU;;AAAzDI;;;AAChD,iCAAA,jCAAMM,0EAAoCV,GAAGV;AAA7C,AACE,IAAMqB,aAAW,EAAI,AAACC,yBAASZ,KAAIA,GAAG,AAACF,cAAIE;AAA3C,AACE,IAAAI,oBACE,CAAI,AAACC,gBAAMf,MAAO,AAACe,gBAAMM;AAD3B,AAAA,GAAAP;AAEE,IAAMS,SAAO,AAACjB,+BAAWe;AAAzB,AACE,OAAChB,oBAAU,WAAKhB,EAAEY,EAAEC;AAAT,AAAY,GAAI,AAACe,0BAAUM,OAAOtB;AAAtB;;AAA8B,yBAAA,lBAACV;;GAAtD,KAA4ES;;AAHhFc;;;AAyJJ,AAAA,AAAA,AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,AAAA,CAAA,AAAA,sFAAA,WAAAU,mBAAAC,pHAAWoE;;AAAX,AAAA,IAAArE,yBAAA;AAAA,AAAA,OAAAA,8DAAAC,gBAAA;;;AAAA,CAAA,AAAA,sFAAA,WAAAC,mBAAAC,OAAAC,3HAAWiE;;AAAX,AAAA,IAAAnE,yBAAA;AAAA,AAAA,IAAAG,WAAAF;IAAAE,eAAA,EAAA,CAAAA,oBAAAC,oBAAA,AAAAD,aAAA;AAAA,AAAA,QAAAA;KAAA;AAAAE;;;KAAA;AAAAC;;;KAAA;AAAA9C;;;KAAA;AAAA+C;;;KAAA;AAAAC;;;KAAA;AAAAC;;;KAAA;AAAAC;;;;AAAA,OAAAxB,4CAAAyB,gBAAAV,OAAAC;;;;;AAAA,CAAA,AAAA,2FAAA,WAAAU,mBAAAC,gBAAAC,zIAAWqD;;AAAX,AAAA,IAAAvD,yBAAA;AAAA,AAAA,OAAAlD,+CAAA,WAAAqD,kBAAAC;AAAA,AAAA,IAAAC,aAAAD;IAAAE,kBAAA,AAAAC,4CAAAF,WAAA,IAAA;IAAAG,kBAAA,AAAAD,4CAAAF,WAAA,IAAA;AAAA,AAAA,QAAAJ,gDAAAA,8CAAAE,kBAAAG,gBAAAE,mBAAAP,0BAAAE,kBAAAG,gBAAAE;GAAAN,mBAAAF;;;AAAA,CAAA,AAAA,kGAAA,WAAAS,mBAAAC,qBAAAC,rJAAW4C;;AAAX,AAAA,IAAA9C,yBAAA;AAAA,AAAA,IAAAG,wBAAA,WAAAC;AAAA,AAAA,OAAAC,+BAAAJ,qBAAA,oBAAA,GAAA,IAAA,GAAAC,mBAAAE;;AAAA,AAAA,OAAAC,+BAAAJ,qBAAAE,sBAAA,4CAAA,KAAA,IAAAD,mBAAA,AAAAI,+CAAA,mFAAA,KAAAC,2BAAA,KAAA,EAAA,IAAA,AAAAA,sCAAA,CAAA,gDAAAvB,WAAA,OAAA,KAAAuB,2BAAA,KAAA,EAAA,IAAA,AAAAA,sCAAA,CAAA,yDAAAtB,eAAA,OAAA,KAAAsB,2BAAA,KAAA,EAAA,IAAA,AAAAA,sCAAA,CAAA,qDAAApE,aAAA,OAAA,KAAAoE,2BAAA,KAAA,EAAA,IAAA,AAAAA,sCAAA,CAAA,6DAAArB,iBAAA,OAAA,KAAAqB,2BAAA,KAAA,EAAA,IAAA,AAAAA,sCAAA,CAAA,2DAAApB,gBAAA,OAAA,KAAAoB,2BAAA,KAAA,EAAA,IAAA,AAAAA,sCAAA,CAAA,qDAAAnB,aAAA,OAAA,KAAAmB,2BAAA,KAAA,EAAA,IAAA,AAAAA,sCAAA,CAAA,uDAAAlB,cAAA,eAAAC;;;AAAA,CAAA,AAAA,0FAAA,WAAAkB,rGAAWsC;;AAAX,AAAA,IAAAtC,eAAA;AAAA,AAAA,YAAAC,qBAAA,IAAAD,aAAA,EAAA,mFAAA,gDAAA,yDAAA,qDAAA,6DAAA,2DAAA,qDAAA,+DAAA,kBAAAlB,iBAAA,AAAAoB,oBAAApB,iBAAA,AAAAqB;;;AAAA,CAAA,AAAA,kFAAA,WAAAC,7FAAWkC;;AAAX,AAAA,IAAAlC,yBAAA;AAAA,AAAAC;;;AAAA,CAAA,AAAA,wFAAA,WAAAC,nGAAWgC;;AAAX,AAAA,IAAAhC,yBAAA;AAAA,AAAA,oDAAA9B,UAAAC,cAAA9C,YAAA+C,gBAAAC,eAAAC,YAAAC,aAAAwB,cAAAvB,gBAAAyB,lKAAW+B;;;AAAX,CAAA,AAAA,sFAAA,WAAA9B,jGAAW8B;;AAAX,AAAA,IAAA9B,yBAAA;AAAA,AAAA,QAAA,IAAA,AAAAhD,gBAAAsB;;;AAAA,CAAA,AAAA,kFAAA,WAAA2B,7FAAW6B;;AAAX,AAAA,IAAA7B,yBAAA;AAAA,AAAA,IAAAC,kBAAAH;AAAA,AAAA,GAAA,GAAA,CAAAG,mBAAA;AAAAA;;AAAA,IAAAA,sBAAA,AAAA,WAAAC;AAAA,AAAA,QAAA,aAAA,AAAAC,8BAAAD;GAAAF;AAAA,AAAA,CAAAF,gBAAAG;;AAAAA;;;;AAAA,CAAA,AAAA,oFAAA,WAAAG,UAAAC,zGAAWwB;;AAAX,AAAA,IAAAzB,gBAAA;AAAA,AAAA,SAAA,GAAA,CAAAC,cAAA,aAAA,EAAA,CAAA,AAAAD,8BAAA,AAAAC,6BAAA,EAAA,AAAAC,6CAAA,AAAAF,iBAAA,AAAAC,oBAAA,EAAA,AAAAC,6CAAA,AAAAF,qBAAA,AAAAC,wBAAA,EAAA,AAAAC,6CAAA,AAAAF,mBAAA,AAAAC,sBAAA,EAAA,AAAAC,6CAAA,AAAAF,uBAAA,AAAAC,0BAAA,EAAA,AAAAC,6CAAA,AAAAF,sBAAA,AAAAC,yBAAA,EAAA,AAAAC,6CAAA,AAAAF,mBAAA,AAAAC,sBAAA,EAAA,AAAAC,6CAAA,AAAAF,oBAAA,AAAAC,uBAAA,AAAAC,6CAAA,AAAAF,uBAAA,AAAAC;;;AAAA,CAAA,AAAA,mFAAA,WAAAE,mBAAAC,jHAAWqB;;AAAX,AAAA,IAAAtB,yBAAA;AAAA,AAAA,GAAA,AAAAtD,0BAAA,iFAAA,0DAAA,8DAAA,qDAAA,kEAAA,gEAAA,4DAAA,yEAAAuD;AAAA,OAAAC,+CAAA,AAAAC,qBAAA,AAAAC,6CAAA,mCAAAJ,wBAAAX,eAAAY;;AAAA,oDAAAzC,UAAAC,cAAA9C,YAAA+C,gBAAAC,eAAAC,YAAAC,aAAAwB,cAAA,AAAAgB,oBAAA,AAAAH,+CAAApC,gBAAAmC,kBAAA,vPAAWqB;;;;AAAX,CAAA,AAAA,wGAAA,WAAAhB,mBAAAlD,tIAAWkE;;AAAX,AAAA,IAAAhB,yBAAA;AAAA,AAAA,IAAAC,WAAAnD;IAAAmD,eAAA,EAAA,CAAAA,oBAAAhD,oBAAA,AAAAgD,aAAA;AAAA,AAAA,QAAAA;KAAA;KAAA;KAAA;KAAA;KAAA;KAAA;KAAA;AAAA;;;;AAAA,OAAA7D,0BAAAoB,gBAAAV;;;;;AAAA,CAAA,AAAA,0FAAA,WAAAoD,mBAAAC,gBAAAzB,xIAAWsC;;AAAX,AAAA,IAAAd,yBAAA;AAAA,AAAA,IAAAE,cAAAC;IAAAC,cAAAH;AAAA,AAAA,oBAAA,CAAAC,4CAAAA,0CAAA,gDAAAE,eAAAF,sBAAA,gDAAAE;AAAA,oDAAA5B,SAAAvB,cAAA9C,YAAA+C,gBAAAC,eAAAC,YAAAC,aAAAwB,cAAAvB,gBAAA,jKAAWwD;;AAAX,oBAAA,CAAAZ,4CAAAA,0CAAA,yDAAAE,eAAAF,sBAAA,yDAAAE;AAAA,oDAAApD,UAAAwB,SAAArE,YAAA+C,gBAAAC,eAAAC,YAAAC,aAAAwB,cAAAvB,gBAAA,7JAAWwD;;AAAX,oBAAA,CAAAZ,4CAAAA,0CAAA,qDAAAE,eAAAF,sBAAA,qDAAAE;AAAA,oDAAApD,UAAAC,cAAAuB,SAAAtB,gBAAAC,eAAAC,YAAAC,aAAAwB,cAAAvB,gBAAA,/JAAWwD;;AAAX,oBAAA,CAAAZ,4CAAAA,0CAAA,6DAAAE,eAAAF,sBAAA,6DAAAE;AAAA,oDAAApD,UAAAC,cAAA9C,YAAAqE,SAAArB,eAAAC,YAAAC,aAAAwB,cAAAvB,gBAAA,3JAAWwD;;AAAX,oBAAA,CAAAZ,4CAAAA,0CAAA,2DAAAE,eAAAF,sBAAA,2DAAAE;AAAA,oDAAApD,UAAAC,cAAA9C,YAAA+C,gBAAAsB,SAAApB,YAAAC,aAAAwB,cAAAvB,gBAAA,5JAAWwD;;AAAX,oBAAA,CAAAZ,4CAAAA,0CAAA,qDAAAE,eAAAF,sBAAA,qDAAAE;AAAA,oDAAApD,UAAAC,cAAA9C,YAAA+C,gBAAAC,eAAAqB,SAAAnB,aAAAwB,cAAAvB,gBAAA,/JAAWwD;;AAAX,oBAAA,CAAAZ,4CAAAA,0CAAA,uDAAAE,eAAAF,sBAAA,uDAAAE;AAAA,oDAAApD,UAAAC,cAAA9C,YAAA+C,gBAAAC,eAAAC,YAAAoB,SAAAK,cAAAvB,gBAAA,9JAAWwD;;AAAX,oDAAA9D,UAAAC,cAAA9C,YAAA+C,gBAAAC,eAAAC,YAAAC,aAAAwB,cAAA,AAAAzD,8CAAAkC,gBAAA2C,gBAAAzB,UAAA,1OAAWsC;;;;;;;;;;AAAX,CAAA,AAAA,oFAAA,WAAAT,/FAAWS;;AAAX,AAAA,IAAAT,yBAAA;AAAA,AAAA,OAAAC,cAAA,AAAAhC,+CAAA,mFAAA,KAAAiC,mBAAA,gDAAAvD,UAAA,OAAA,KAAAuD,mBAAA,yDAAAtD,cAAA,OAAA,KAAAsD,mBAAA,qDAAApG,YAAA,OAAA,KAAAoG,mBAAA,6DAAArD,gBAAA,OAAA,KAAAqD,mBAAA,2DAAApD,eAAA,OAAA,KAAAoD,mBAAA,qDAAAnD,YAAA,OAAA,KAAAmD,mBAAA,uDAAAlD,aAAA,eAAAC;;;AAAA,CAAA,AAAA,2FAAA,WAAAkD,mBAAAhC,zHAAWsC;;AAAX,AAAA,IAAAN,yBAAA;AAAA,AAAA,oDAAAxD,UAAAC,cAAA9C,YAAA+C,gBAAAC,eAAAC,YAAAC,aAAAmB,SAAAlB,gBAAAyB,7JAAW+B;;;AAAX,CAAA,AAAA,wFAAA,WAAAL,mBAAAC,tHAAWI;;AAAX,AAAA,IAAAL,yBAAA;AAAA,AAAA,GAAA,AAAAE,wBAAAD;AAAA,OAAAD,kEAAA,AAAAG,eAAAF,oBAAA,KAAA,AAAAE,eAAAF,oBAAA;;AAAA,OAAArG,+CAAAwG,gBAAAJ,uBAAAC;;;;AAAA,CAAA,AAAAI,mDAAA;AAAA,AAAA,AAAA;;;AAAA,CAAA,AAAAA,yDAAA;;AAAA,CAAA,AAAAA,8DAAA,WAAAC;AAAA,AAAA,YAAAC,eAAA,KAAA,0CAAA,KAAA,IAAA;;;AAAA,CAAA,AAAAF,iEAAA,WAAAC,mBAAAE;AAAA,AAAA,OAAAC,iBAAAD,qBAAA;;;AAAA;;;+CAAA,/CAAWM,sGAAqBvE,GAAGC,OAAQ9C,KAAK+C,SAASC,QAASC,KAAKC;AAAvE,AAAA,YAAAyD,mFAAA,KAAA,KAAA,rDAAgC9D,GAAGC,OAAQ9C,KAAK+C,SAASC,QAASC,KAAKC;;;AAAvE;;;kDAAA,0DAAA8D,5GAAWK;AAAX,AAAA,IAAAJ,uBAAA,iBAAAC,WAAA,AAAA3B,sDAAAyB,SAAA,kGAAA,yDAAA,qDAAA,6DAAA,2DAAA,qDAAA;AAAA,AAAA,GAAA,AAAAG,wBAAAH;AAAA,OAAAvB,6CAAA,mCAAAyB;;AAAAA;;;AAAA,AAAA,YAAAP,wCAAA,AAAA,8EAAAK,UAAA,AAAA,uFAAAA,UAAA,AAAA,mFAAAA,UAAA,AAAA,2FAAAA,UAAA,AAAA,yFAAAA,UAAA,AAAA,mFAAAA,UAAA,AAAA,qFAAAA,UAAA,KAAA,AAAAtB,oBAAAuB,sBAAA;;;AAAAN,AACA,AAAA;;;;;;;AAAA;AAAA,CAAA,4CAAA,5CAASc;AAAT,AAAA,AAAA;;;AAAA,CAAA,kDAAA,lDAASA;;AAAT,CAAA,qDAAA,rDAASA;;AAAT,CAAA,0DAAA,WAAAH,mBAAAC,qBAAAC,7GAASC;AAAT,AAAA,OAAAV,iBAAAQ,qBAAA;;;AAAA;;;wCAAA,xCAASG,wFAAcC;AAAvB,AAAA,YAAAF,iCAAuBE;;;AAAdF,AACT,AAAOG,qCAAuC;AAmD9C","names":["taoensso.truss.impl/re-pattern?","x","js/RegExp","taoensso.truss.impl/str-contains?","s","substr","cljs.core.not_EQ_","taoensso.truss.impl/revery?","pred","coll","cljs.core.reduce","_","in","cljs.core/reduced","taoensso.truss.impl/revery","taoensso.truss.impl/rsome","temp__5823__auto__","p","var_args","G__46005","taoensso.truss.impl/assoc-some","js/Error","m","k","v","cljs.core.assoc","m-kvs","cljs.core/reduce-kv","taoensso.truss.impl/ensure-set","cljs.core/set?","cljs.core/set","taoensso.truss.impl/ks-nnil?","ks","p1__46011#","cljs.core.get","taoensso.truss.impl/ks=","and__5023__auto__","cljs.core/count","p1__46013#","cljs.core/contains?","taoensso.truss.impl/ks>=","p1__46017#","taoensso.truss.impl/ks<=","counted-ks","cljs.core/counted?","ks-set","this__5323__auto__","k__5324__auto__","this__5325__auto__","k46043","else__5326__auto__","G__46047","cljs.core/Keyword","ns","coords","arg-form","arg-val","data","error","__extmap","this__5343__auto__","f__5344__auto__","init__5345__auto__","ret__5346__auto__","p__46053","vec__46054","k__5347__auto__","cljs.core.nth","v__5348__auto__","this__5338__auto__","writer__5339__auto__","opts__5340__auto__","pr-pair__5341__auto__","keyval__5342__auto__","cljs.core/pr-sequential-writer","cljs.core.concat","cljs.core/PersistentVector","G__46042","cljs.core/RecordIter","cljs.core/-iterator","cljs.core/nil-iter","this__5321__auto__","__meta","this__5318__auto__","__hash","this__5327__auto__","this__5319__auto__","h__5134__auto__","coll__5320__auto__","cljs.core/hash-unordered-coll","this46044","other46045","cljs.core._EQ_","this__5333__auto__","k__5334__auto__","cljs.core.dissoc","cljs.core/-with-meta","cljs.core.into","cljs.core/not-empty","this__5330__auto__","G__46066","this__5331__auto__","k__5332__auto__","pred__46067","cljs.core/keyword-identical?","expr__46068","this__5336__auto__","cljs.core/seq","cljs.core/MapEntry","this__5322__auto__","this__5328__auto__","entry__5329__auto__","cljs.core/vector?","cljs.core/-nth","cljs.core/-conj","taoensso.truss.impl/FailedAssertionInfo","this__5369__auto__","cljs.core/List","writer__5370__auto__","cljs.core/-write","G__46046","extmap__5365__auto__","G__46090","cljs.core/record?","taoensso.truss.impl/->FailedAssertionInfo","taoensso.truss.impl/map->FailedAssertionInfo","this__5310__auto__","writer__5311__auto__","opt__5312__auto__","taoensso.truss.impl/ArgEvalError","taoensso.truss.impl/->ArgEvalError","ex","taoensso.truss.impl/FalsePredError"],"sourcesContent":["(ns ^:no-doc taoensso.truss.impl\n  \"Private implementation details.\"\n  (:require\n   [clojure.set :as set]\n   #?(:clj [clojure.java.io :as jio]))\n  #?(:cljs\n     (:require-macros\n      [taoensso.truss.impl :refer\n       [catching now-inst* and? or?]])))\n\n(comment (require '[taoensso.encore :as enc]))\n\n;;;;\n\n#?(:clj (defmacro legacy-assertion-ex-data? [] (= (System/getProperty \"taoensso.truss.legacy-assertion-ex-data\") \"true\")))\n\n;;;; Encore imports\n\n#?(:clj (defn list-form? [x] (or (list? x) (instance? clojure.lang.Cons x))))\n\n#?(:clj  (defn          re-pattern? [x] (instance? java.util.regex.Pattern x))\n   :cljs (defn ^boolean re-pattern? [x] (instance? js/RegExp               x)))\n\n#?(:clj (defmacro now-dt*   [] (if (:ns &env) `(js/Date.) `(java.util.Date.))))\n#?(:clj (defmacro now-inst* [] (if (:ns &env) `(js/Date.) `(java.time.Instant/now))))\n#?(:clj\n   (defmacro identical-kw? [x y]\n     (if (:ns &env)\n       `(cljs.core/keyword-identical? ~x ~y)\n       `(identical?                   ~x ~y))))\n\n(defn str-contains?\n  #?(:cljs {:tag 'boolean})\n  [s substr]\n  #?(:clj  (.contains ^String s ^String substr)\n     :cljs (not= -1 (.indexOf s substr))))\n\n(defn revery? #?(:cljs {:tag 'boolean}) [pred coll] (reduce (fn [_ in] (if (pred in) true (reduced false))) true coll))\n(defn revery                            [pred coll] (reduce (fn [_ in] (if (pred in) coll (reduced   nil))) coll coll))\n(defn rsome                             [pred coll] (reduce (fn [_ in] (when-let [p (pred in)] (reduced p))) nil coll))\n(defn assoc-some\n  ([m k v      ] (if-not (nil? v) (assoc m k v) m))\n  ([m     m-kvs] (reduce-kv  assoc-some m m-kvs)))\n\n(defn ensure-set [x] (if (set? x) x (set x)))\n(defn ks-nnil? #?(:cljs {:tag 'boolean}) [ks m] (revery? #(some? (get m %)) ks))\n(defn ks=      #?(:cljs {:tag 'boolean}) [ks m] (and (== (count m) (count ks)) (revery? #(contains? m %) ks)))\n(defn ks>=     #?(:cljs {:tag 'boolean}) [ks m] (and (>= (count m) (count ks)) (revery? #(contains? m %) ks)))\n(defn ks<=     #?(:cljs {:tag 'boolean}) [ks m]\n  (let [counted-ks (if (counted? ks) ks (set ks))]\n    (and\n      (<= (count m)     (count counted-ks))\n      (let [ks-set (ensure-set counted-ks)]\n        (reduce-kv (fn [_ k v] (if (contains? ks-set k) true (reduced false))) true m)))))\n\n#?(:clj\n   (defmacro catching\n     ([try-expr                     ] `(catching ~try-expr ~'_ nil))\n     ([try-expr error-sym catch-expr]\n      (if (:ns &env)\n        `(try ~try-expr (catch :default  ~error-sym ~catch-expr))\n        `(try ~try-expr (catch Throwable ~error-sym ~catch-expr))))))\n\n#?(:clj\n   (defn- var-info [macro-env sym]\n     (when (symbol? sym)\n       (if (:ns macro-env)\n         (let [ns (find-ns 'cljs.analyzer.api)\n               v  (ns-resolve ns 'resolve)] ; Don't cache!\n           (when-let [{:as m, var-ns :ns, var-name :name} ; ?{:keys [meta ns name ...]}\n                      (@v macro-env sym)]\n             (when var-ns ; Skip locals\n               (assoc m :sym (symbol (str var-ns) (name var-name))))))\n\n         (when-let [v (resolve macro-env sym)]\n           (let [{:as m, var-ns :ns, var-name :name} (meta v)]\n             {:var  v\n              :sym  (symbol (str var-ns) (name var-name))\n              :ns   var-ns\n              :name var-name\n              :meta\n              (if-let [x (get m :arglists)]\n                (assoc m :arglists `'~x) ; Quote\n                (do    m))}))))))\n\n#?(:clj (defmacro and? ([] true)  ([x] x) ([x & next] `(if ~x (and? ~@next) false))))\n#?(:clj (defmacro or?  ([] false) ([x] x) ([x & next] `(if ~x true (or? ~@next)))))\n\n;;;; Assertion predicates\n\n#?(:clj (defn ensure-set-form [form] (if (set? form) form `(ensure-set ~form))))\n#?(:clj (def ^:private safe-pred-forms\n          (let [names\n                (mapv name\n                  '#{nil? some? string? integer? number? symbol? keyword? float?\n                     set? vector? coll? list? ifn? fn? associative? sequential? delay?\n                     sorted? counted? reversible? true? false? identity not boolean})]\n            (-> #{}\n              (into (mapv #(symbol \"clojure.core\" %) names))\n              (into (mapv #(symbol    \"cljs.core\" %) names))))))\n\n#?(:clj\n   (defn parse-pred-form\n     \"Returns [safe? form show special?].\"\n     ([macro-env pred-form              ] (parse-pred-form macro-env pred-form false nil))\n     ([macro-env pred-form in-comp? gsym]\n      (if-not (vector? pred-form)\n        ;; Standard predicate\n        (let [{:keys [meta sym]} (var-info macro-env pred-form)\n              safe?\n              (or\n                (get meta :truss/safe)\n                (keyword? pred-form)\n                (map?     pred-form)\n                (set?     pred-form)\n                (contains? safe-pred-forms sym))]\n\n          [safe? (or sym pred-form) sym])\n\n        ;; Special predicate\n        (let [[kind a1 a2 a3]      pred-form\n              num-args (dec (count pred-form))\n              _\n              (when (or (< num-args 1) (> num-args 3))\n                (throw\n                  (ex-info \"Truss special predicates should have 1\u2264n\u22643 elements\"\n                    {:pred-form pred-form})))\n\n              gsym (or gsym (gensym \"arg\"))\n\n              [safe? body]\n              (case kind\n                :set=             [false `(=             (ensure-set ~gsym) ~(ensure-set-form a1))]\n                :set<=            [false `(set/subset?   (ensure-set ~gsym) ~(ensure-set-form a1))]\n                :set>=            [false `(set/superset? (ensure-set ~gsym) ~(ensure-set-form a1))]\n\n                :ks=              [false `(ks=           ~(ensure-set-form a1) ~gsym)]\n                :ks<=             [false `(ks<=          ~(ensure-set-form a1) ~gsym)]\n                :ks>=             [false `(ks>=          ~(ensure-set-form a1) ~gsym)]\n                :ks-nnil?         [false `(ks-nnil?      ~(ensure-set-form a1) ~gsym)]\n                (    :el     :in) [false     `(contains? ~(ensure-set-form a1) ~gsym)]\n                (:not-el :not-in) [false `(if (contains? ~(ensure-set-form a1) ~gsym) false true)]\n\n                :n=               [false `(=  (count ~gsym) ~a1)]\n                :n>=              [false `(>= (count ~gsym) ~a1)]\n                :n<=              [false `(<= (count ~gsym) ~a1)]\n\n                :instance?        [false `(instance?  ~a1 ~gsym)]\n                :satisfies?       [false `(satisfies? ~a1 ~gsym)]\n\n                (:and :or :not) ; Composition\n                (let [;; Support recursive expansion\n                      [sf3? a3 _ sp3?] (when a3 (parse-pred-form macro-env a3 :in-comp gsym))\n                      [sf2? a2 _ sp2?] (when a2 (parse-pred-form macro-env a2 :in-comp gsym))\n                      [sf1? a1 _ sp1?] (when a1 (parse-pred-form macro-env a1 :in-comp gsym))\n\n                      a3-test (when a3 (if sp3? a3 `(~a3 ~gsym)))\n                      a2-test (when a2 (if sp2? a2 `(~a2 ~gsym)))\n                      a1-test (when a1 (if sp1? a1 `(~a1 ~gsym)))\n\n                      ;; [:and ...] comp is safe if all preds are safe\n                      ;; [:or  ...] comp ensures that all but last pred are safe\n\n                      in-or?         (= kind :or)\n                      [sf2? a2-test] (if (and in-or? a3 (not sf2?)) [true `(catching ~a2-test)] [sf2? a2-test])\n                      [sf1? a1-test] (if (and in-or? a2 (not sf1?)) [true `(catching ~a1-test)] [sf1? a1-test])\n\n                      sf-all? (boolean (and (if a1 sf1? true) (if a2 sf2? true) (if a3 sf3? true)))\n                      body\n                      (case kind\n                        :or ; any-of\n                        (cond\n                          a3 `(or? ~a1-test ~a2-test ~a3-test)\n                          a2 `(or? ~a1-test ~a2-test)\n                          a1        a1-test)\n\n                        :and ; all-of\n                        (cond\n                          a3 `(and? ~a1-test ~a2-test ~a3-test)\n                          a2 `(and? ~a1-test ~a2-test)\n                          a1         a1-test)\n\n                        :not ; none-of, same as [:and (not a1) (not a2) ...]\n                        (cond\n                          a3 `(if (or? ~a1-test ~a2-test ~a3-test) false true)\n                          a2 `(if (or? ~a1-test ~a2-test)          false true)\n                          a1 `(if      ~a1-test                    false true)))]\n\n                  [sf-all? body])\n\n                (throw\n                  (ex-info \"Unexpected Truss special predicate kind\"\n                    {:pred-form pred-form})))]\n\n          (let [safe? (boolean safe?)\n                form  (if in-comp? body `(fn [~gsym] ~body))\n                show  pred-form]\n\n            [safe? form show :special]))))))\n\n;;;; Assertions\n\n;; User-facing record provided to `*failed-assertion-handler*`\n(defrecord FailedAssertionInfo [ns coords, pred arg-form arg-val, data error])\n(deftype ArgEvalError [ex]) ; Private wrapper type to identiy exceptions evaluating args or executing (pred arg) checks\n(def   FalsePredError #?(:clj (Object.) :cljs (js-obj))) ; Private object to identify falsey (pred arg) checks\n\n#?(:clj\n   (defmacro assert1\n     [bool? coords [psafe? pform pshow] arg-form data-fn-form]\n     (let [cljs?         (:ns &env)\n           [line column] coords\n           eval-arg?     (list-form? arg-form)\n           ns            (str *ns*)\n\n           gs-error   (gensym \"error\")\n           gs-arg-val (gensym \"arg-val\")]\n\n       (case [(if eval-arg? :eval-arg  :local-arg)\n              (if psafe?    :safe-pred :unsafe-pred)]\n\n         [:local-arg :safe-pred]\n         `(if (~pform ~arg-form)\n            ~(if bool? true arg-form)\n            (taoensso.truss/failed-assertion! ~ns ~line ~column ~pshow '~arg-form ~arg-form ~data-fn-form nil))\n\n         [:local-arg :unsafe-pred]\n         `(let [~gs-error (catching (if (~pform ~arg-form) nil FalsePredError) ~'e ~'e)]\n            (if ~gs-error\n              (taoensso.truss/failed-assertion! ~ns ~line ~column ~pshow '~arg-form ~arg-form ~data-fn-form ~gs-error)\n              ~(if bool? true arg-form)))\n\n         [:eval-arg :safe-pred]\n         `(let [~gs-arg-val (catching ~arg-form ~'e (ArgEvalError. ~'e))\n                ~gs-error\n                (if (instance? ArgEvalError ~gs-arg-val)\n                  ~gs-arg-val\n                  (if (~pform ~gs-arg-val) nil FalsePredError))]\n\n            (if ~gs-error\n              (taoensso.truss/failed-assertion! ~ns ~line ~column ~pshow '~arg-form ~gs-arg-val ~data-fn-form ~gs-error)\n              ~(if bool? true gs-arg-val)))\n\n         [:eval-arg :unsafe-pred]\n         `(let [~gs-arg-val (catching ~arg-form ~'e (ArgEvalError. ~'e))\n                ~gs-error\n                (if (instance? ArgEvalError ~gs-arg-val)\n                  ~gs-arg-val\n                  (catching\n                    (if (~pform ~gs-arg-val) nil FalsePredError)\n                    ~'e ~'e))]\n\n            (if ~gs-error\n              (taoensso.truss/failed-assertion! ~ns ~line ~column ~pshow '~arg-form ~gs-arg-val ~data-fn-form ~gs-error)\n              ~(if bool? true gs-arg-val)))))))\n\n(comment (macroexpand '(assert1 true [0 0] [true string? string?] \"foo\" (fn [] (+ 3 2)))))\n\n#?(:clj\n   (defmacro assert-args\n     \"Low-level `assert` wrapper for `have`-style API.\"\n     [elidable? bool? coords arg-forms]\n     (let [bang?      (= (first arg-forms) :!) ; For back compatibility, undocumented\n           elidable?  (and elidable? (not bang?))\n           elide?     (and elidable? (not *assert*))\n           arg-forms  (if bang? (next arg-forms) arg-forms)\n           in?        (= (second arg-forms) :in) ; (have pred :in xs1 xs2 ...)\n           arg-forms  (if in? (cons (first arg-forms) (nnext arg-forms)) arg-forms)\n           data-fn-form\n           (when (and\n                   (> (count arg-forms) 2) ; Distinguish from `:data` pred\n                   (= (last (butlast arg-forms)) :data))\n             `(fn [] ~(last arg-forms)))\n\n           arg-forms  (if data-fn-form (butlast (butlast arg-forms)) arg-forms)\n           auto-pred? (= (count arg-forms) 1) ; Unique common case: (have ?x)\n           pred-form  (if auto-pred? `some? (first arg-forms))\n           [?x1 ?xs]\n           (cond\n             auto-pred?        [(first arg-forms)  nil]\n             (nnext arg-forms) [nil   (next arg-forms)]\n             :else             [(second arg-forms) nil])\n\n           single-x? (nil? ?xs)\n\n           [psafe? pform pshow] (parse-pred-form &env pred-form)\n           gs-ps (gensym \"ps\")\n           gs-pf (gensym \"pf\")\n           gs-df (gensym \"df\")\n           gs-in (gensym \"in\")]\n\n       (if elide?\n         (if bool? true (if single-x? ?x1 (vec ?xs)))\n\n         (case [(if in?       :in       :not-in)\n                (if single-x? :single-x :multi-x)]\n\n           [:not-in :single-x] ; (have* pred x) -> x or bool\n           `(assert1 ~bool? ~coords [~psafe? ~pform '~pshow] ~?x1 ~data-fn-form)\n\n           [:not-in :multi-x] ; (have* pred x1 x2 ...) -> [x1 x2 ...] or bool\n           (let [body (mapv (fn [x] `(assert1 ~bool? ~coords [~psafe? ~gs-pf ~gs-ps] ~x ~gs-df)) ?xs)\n                 body (if bool? `(do ~@body true) body)]\n             `(let [~gs-ps '~pshow\n                    ~gs-pf  ~pform\n                    ~gs-df  ~data-fn-form]\n                ~body))\n\n           [:in :single-x] ; (have* pred :in xs) -> xs or bool\n           (let [rfn (if bool? `revery? `revery)]\n             `(let [~gs-ps '~pshow\n                    ~gs-pf  ~pform\n                    ~gs-df  ~data-fn-form]\n                (~rfn (fn [~gs-in] (assert1 ~bool? ~coords [~psafe? ~gs-pf ~gs-ps] ~gs-in ~gs-df)) ~?x1)))\n\n           [:in :multi-x] ; (have* pred :in xs1 xs2 ...) -> [xs1   ...] or bool\n           (let [rfn  (if bool? `revery? `revery)\n                 body (mapv (fn [xs] `(~rfn (fn [~gs-in] (assert1 ~bool? ~coords [~psafe? ~gs-pf ~gs-ps] ~gs-in ~gs-df)) ~xs)) ?xs)\n                 body (if bool? `(do ~@body true) body)]\n             `(let [~gs-ps '~pshow\n                    ~gs-pf  ~pform\n                    ~gs-df  ~data-fn-form]\n                ~body)))))))\n"],"x_google_ignoreList":[0]}