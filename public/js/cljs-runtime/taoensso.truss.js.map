{"version":3,"sources":["taoensso/truss.cljc"],"mappings":"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","names":["taoensso.truss/submap?","super-map","sub-map","cljs.core/reduce-kv","_","sub-key","sub-val","cljs.core/map?","super-val","cljs.core.get","temp__5821__auto__","match?","and__5023__auto__","cljs.core/reduced","pred-fn","cljs.core/fn?","G__46625","cljs.core/Keyword","cljs.core/keyword-identical?","cljs.core._EQ_","taoensso.truss/*ctx*","var_args","G__46640","taoensso.truss/ex-info","js/Error","msg","taoensso.truss.ex_info","data-map","cause","ctx","cljs.core.ex_info","cljs.core.assoc","G__46648","taoensso.truss/ex-info!","taoensso.truss/set-ctx!","root-ctx-val","taoensso.truss/update-ctx","old-ctx","update-map-or-fn","cljs.core.conj","cljs.core/ifn?","G__46653","G__46654","taoensso.truss/unexpected-arg!","taoensso.truss/error?","x","taoensso.truss/ex-root","error","cljs.core/ex-cause","taoensso.truss/ex-type","cljs.core/ExceptionInfo","cljs.core.symbol","taoensso.truss/ex-map*","temp__5823__auto__","cljs.core/ex-message","data","cljs.core/not-empty","cljs.core/ex-data","G__46661","taoensso.truss/ex-chain","taoensso.truss.ex_chain","as-maps?","xf","cljs.core/identity","acc","taoensso.truss/ex-map","chain","maps","cljs.core.mapv","root","cljs.core/peek","root-map","taoensso.truss.impl.assoc_some","st","G__46675","arg","taoensso.truss.unexpected_arg_BANG_","opts","or__5025__auto__","cljs.core/type","cljs.core.dissoc","k1","v1","k2","v2","k3","v3","k4","v4","G__46687","taoensso.truss/matching-error","kind","G__46691","cljs.core/set?","p1__46682#","taoensso.truss.impl/rsome","taoensso.truss.matching_error","pattern","p1__46684#","taoensso.truss.impl/str-contains?","taoensso.truss.impl/re-pattern?","cljs.core/re-find","get-default-error-fn","base-data","G__46698","taoensso.truss/catching-rf","rf","taoensso.truss.catching_rf","error-fn","e46699","t","G__46700","G__46701","e46704","G__46705","G__46706","in","e46707","G__46708","G__46709","k","v","e46710","G__46711","G__46712","G__46714","taoensso.truss/catching-xform","xform","cljs.core.comp","newline","legacy-ex-data?","G__46716","taoensso.truss/failed-assertion-ex-info","failed-assertion-info","taoensso.truss.failed_assertion_ex_info","map__46717","cljs.core/--destructure-map","inst","ns","coords","pred","arg-form","arg-val","undefined-arg?","coords-str","vec__46718","cljs.core.nth","line","column","cljs.core/List","error-msg","js/Date","vec__46721","cljs.core/*assert*","taoensso.truss/*failed-assertion-handler*","taoensso.truss/failed-assertion!","data-fn","handler","G__46737","taoensso.truss.impl/ArgEvalError","taoensso.truss.impl/FailedAssertionInfo","df","e46756","taoensso.truss.impl/FalsePredError","taoensso.truss/get-dynamic-assertion-data","taoensso.truss/get-data","taoensso.truss/set-error-fn!","f"],"sourcesContent":["(ns taoensso.truss\n  \"A micro toolkit for Clojure/Script errors.\"\n  {:author \"Peter Taoussanis (@ptaoussanis)\"}\n  (:refer-clojure :exclude [ex-info])\n  (:require\n   #?(:clj  [clojure.core :as core]\n      :cljs [cljs.core    :as core])\n\n   #?(:clj  [taoensso.truss.impl :as impl])\n   #?(:cljs [taoensso.truss.impl :as impl :refer [FailedAssertionInfo ArgEvalError]]))\n\n  #?(:cljs\n     (:require-macros\n      [taoensso.truss :refer [typed-val try*]]))\n\n  #?(:clj\n     (:import\n      [taoensso.truss.impl FailedAssertionInfo ArgEvalError])))\n\n(comment\n  (require '[taoensso.encore :as enc])\n  (enc/sortv (:api (enc/interns-overview))))\n\n;;;; Callsites\n\n#?(:clj\n   (defn callsite-coords\n     \"Returns [line column] from meta on given macro `&form`.\n     See also `keep-callsite`.\"\n     [macro-form]\n     (when-let [{:keys [line column]} (meta macro-form)]\n       (when line (if column [line column] [line])))))\n\n#?(:clj (defn ^:no-doc merge-callsite [macro-form inner-form] (vary-meta inner-form merge (meta macro-form))))\n#?(:clj\n   (defmacro keep-callsite\n     \"CLJ-865 means that it's not possible for an inner macro to access `&form`\n     metadata (incl. {:keys [line column]}) of a wrapping outer macro:\n\n       (defmacro inner [] (meta &form))\n       (defmacro outer [] `(inner))\n       (outer) => nil\n\n     This util offers a workaround for authors of the outer macro, preserving\n     the outer `&form` metadata for the inner macro:\n\n       (defmacro inner [] (meta &form))\n       (defmacro outer [] (keep-callsite `(inner)))\n       (outer) => {:keys [line column ...]}\"\n     [inner-form] `(merge-callsite ~'&form ~inner-form)))\n\n;;;; Misc\n\n(defn submap?\n  \"Returns true iff `sub-map` is a (possibly nested) submap of `super-map`,\n  i.e. iff every (nested) value in `sub-map` has the same (nested) value in `super-map`.\n\n  `sub-map` may contain special values:\n    `:submap/nx`     - Matches iff `super-map` does not contain key\n    `:submap/ex`     - Matches iff `super-map` does     contain key (any     val)\n    `:submap/some`   - Matches iff `super-map` does     contain key (non-nil val)\n    (fn [super-val]) - Matches iff given unary predicate returns truthy\n\n  Uses stack recursion so supports only limited nesting.\"\n  [super-map sub-map]\n  (reduce-kv\n    (fn [_ sub-key sub-val]\n      (if (map?    sub-val)\n        (let [super-val (get super-map sub-key)]\n          (if-let [match? (and (map? super-val) (submap? super-val sub-val))]\n            true\n            (reduced false)))\n\n        (let [super-val (get super-map sub-key ::nx)]\n          (if-let [match?\n                   (if-let [pred-fn (when (fn? sub-val) sub-val)]\n                     (pred-fn super-val)\n                     (case sub-val\n                       :submap/nx      (impl/identical-kw? super-val ::nx)\n                       :submap/ex (not (impl/identical-kw? super-val ::nx))\n                       :submap/some                 (some? super-val)\n                       (= sub-val super-val)))]\n            true\n            (reduced false)))))\n    true\n    sub-map))\n\n;;;; Error context\n\n(def ^:dynamic *ctx*\n  \"Optional context to add to the data of exceptions created by `truss/ex-info`.\n\n  Value may be any type, but is usually nil or a map. Default (root) value is nil.\n  When present, value will be assoc'ed to `:truss/ctx` key of exception data.\n\n  Useful for dynamically providing arbitrary contextual info to exceptions:\n\n  Re/bind dynamic        value using `with-ctx`, `with-ctx+`, or `binding`.\n  Modify  root (default) value using `set-ctx!`.\n\n  As with all dynamic Clojure vars, \\\"binding conveyance\\\" applies when using\n  futures, agents, etc.\"\n  nil)\n\n(defn ex-info\n  \"Like `core/ex-info` but when dynamic `*ctx*` value is present, it will be\n  assoc'ed to `:truss/ctx` key of returned exception's data.\n\n  Useful for dynamically providing arbitrary contextual info to exceptions.\n  See `*ctx*` for details.\"\n  ([msg               ] (ex-info msg {}       nil))\n  ([msg data-map      ] (ex-info msg data-map nil))\n  ([msg data-map cause]\n   (if-let [ctx *ctx*]\n     (core/ex-info msg (assoc data-map :truss/ctx ctx) cause)\n     (core/ex-info msg        data-map                 cause))))\n\n(defn ex-info!\n  \"Throws a `truss/ex-info`.\"\n  ([msg               ] (throw (ex-info msg {}       nil)))\n  ([msg data-map      ] (throw (ex-info msg data-map nil)))\n  ([msg data-map cause] (throw (ex-info msg data-map cause))))\n\n(defn set-ctx!\n  \"Set `*ctx*` var's default (root) value. See `*ctx*` for details.\"\n  [root-ctx-val]\n  #?(:clj  (alter-var-root (var *ctx*) (fn [_] root-ctx-val))\n     :cljs (set!                *ctx*          root-ctx-val)))\n\n(defmacro with-ctx\n  \"Evaluates given form with given `*ctx*` value. See `*ctx*` for details.\"\n  [ctx-val form] `(binding [*ctx* ~ctx-val] ~form))\n\n(declare unexpected-arg!)\n\n(defn ^:no-doc update-ctx\n  \"Returns `new-ctx` given `old-ctx` and an update map or fn.\"\n  [old-ctx update-map-or-fn]\n  (cond\n    (nil? update-map-or-fn)           old-ctx\n    (map? update-map-or-fn) (conj (or old-ctx) update-map-or-fn) ; Before ifn\n    (ifn? update-map-or-fn) (update-map-or-fn old-ctx)\n    :else\n    (unexpected-arg! update-map-or-fn\n      {:param       'update-map-or-fn\n       :context  `update-ctx\n       :expected '#{nil map fn}})))\n\n(defmacro with-ctx+\n  \"Evaluates given form with updated `*ctx*` value.\n\n  `update-map-or-fn` may be:\n    - A map to merge with    current `*ctx*` value, or\n    - A unary fn to apply to current `*ctx*` value\n\n  See `*ctx*` for details.\"\n  [update-map-or-fn form]\n  `(binding [*ctx* (update-ctx *ctx* ~update-map-or-fn)]\n     ~form))\n\n;;;; Error utils\n\n#?(:clj (defmacro ^:no-doc typed-val [x] `{:value ~x, :type (type ~x)}))\n\n(defn error?\n  \"Returns true iff given platform error (`Throwable` or `js/Error`).\"\n  #?(:cljs {:tag 'boolean})\n  [x]\n  #?(:clj  (instance? Throwable x)\n     :cljs (instance? js/Error  x)))\n\n(defn ^:no-doc ex-root\n  \"Private, don't use.\n  Returns root cause of given platform error.\"\n  [x]\n  (when (error? x)\n    (loop [error x]\n      (if-let [cause (ex-cause error)]\n        (recur cause)\n        error))))\n\n(comment (ex-root (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"}))))\n\n(defn ^:no-doc ex-type\n  \"Private, don't use.\n  Returns class symbol of given platform error.\"\n  [x]\n  #?(:clj (symbol (.getName (class x)))\n     :cljs\n     (cond\n       (instance? ExceptionInfo x) `ExceptionInfo ; Note namespaced\n       (instance? js/Error      x) (symbol \"js\" (.-name x)))))\n\n(defn ^:no-doc ex-map*\n  \"Private, don't use.\n  Returns ?{:keys [type msg data]} for given platform error.\"\n  [x]\n  (when-let [msg             (ex-message x)]\n    (if-let [data (not-empty (ex-data    x))]\n      {:type (ex-type x), :msg msg, :data data}\n      {:type (ex-type x), :msg msg})))\n\n(comment (ex-map* (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"}))))\n\n(defn ^:no-doc ex-chain\n  \"Private, don't use.\n  Returns vector cause chain of given platform error.\"\n  ([         x] (ex-chain false x))\n  ([as-maps? x]\n   (when (error? x)\n     (let [xf (if as-maps? ex-map* identity)]\n       (loop [acc [(xf x)], error x]\n         (if-let [cause (ex-cause error)]\n           (recur (conj acc (xf cause)) cause)\n           (do          acc)))))))\n\n(comment (ex-chain :as-maps (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"}))))\n\n#?(:clj\n   (defn- st-element->map [^StackTraceElement ste]\n     {:class  (symbol (.getClassName  ste))\n      :method (symbol (.getMethodName ste))\n      :file           (.getFileName   ste)\n      :line           (.getLineNumber ste)}))\n\n;; #?(:clj\n;;    (defn- st-element->str ^String [^StackTraceElement ste]\n;;      (str\n;;        \"`\" (.getClassName ste) \"/\" (.getMethodName ste) \"`\"\n;;        \" at \" (.getFileName ste) \":\" (.getLineNumber ste))))\n\n(defn ^:no-doc ex-map\n  \"Private, don't use.\n  Returns ?{:keys [type msg data chain trace]} for given platform error.\"\n  [x]\n  (when-let [chain (ex-chain x)]\n    (let [maps     (mapv ex-map* chain)\n          root     (peek chain)\n          root-map (peek maps)]\n\n      (impl/assoc-some root-map\n        {:chain maps\n         :trace\n         #?(:cljs (when-let [st (.-stack root)] (when-not (= st \"\") st))\n            :clj\n            (when-let [st (not-empty (.getStackTrace ^Throwable root))] ; Don't delay\n              (delay (mapv st-element->map st))))}))))\n\n(comment\n  (ex-map  (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"})))\n  (ex-map  (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"})))\n  (let [ex (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"}))]\n    (enc/qb 1e5 ; [21.22 114.51]\n      (ex-map         ex)\n      (Throwable->map ex))))\n\n#?(:clj (defn ^:no-doc critical-error?     [x] (and (instance? Error     x) (not (instance? AssertionError x)))))\n#?(:clj (defn-     non-critical-throwable? [x] (and (instance? Throwable x) (not (critical-error? x)))))\n#?(:clj\n   (defn ^:no-doc throw-critical\n     \"Private, don't use.\n     If given any `Error` besides `AssertionError`, (re)throw it.\n     Useful as a hack to allow easily catching both `Exception` and `AssertionError`:\n       (try <body> (catch Throwable t (throw-critical t) <body>)), etc.\"\n     [x] (when (critical-error? x) (throw x))))\n\n#?(:clj\n   (defmacro try*\n     \"Like `try`, but `catch` clause class may be:\n       `:ex-info` -- Catches only `ExceptionInfo`\n       `:common` --- Catches `js/Error` (Cljs), `Exception` (Clj)\n       `:all` ------ Catches `:default` (Cljs), `Throwable` (Clj)\n       `:default` -- Catches `:default` (Cljs), `Exception`, and `AssertionError` (Clj)\n                     but NOT other (usually critical) `Error`s\n\n     Addresses CLJ-1293 and the fact that `AssertionError`s are typically NON-critical\n     (so desirable to catch, in contrast to other `Error` classes).\"\n     {:arglists '([expr* catch-clauses* ?finally-clause])}\n     [& forms]\n     (let [cljs? (some? (:ns &env))\n           forms\n           (mapv\n             (fn [in]\n               (if-not (impl/list-form? in)\n                 in\n                 (let [[s1 s2 s3 & more] in]\n                   (cond\n                     (not= s1 'catch)    in\n                     (not (keyword? s2)) in\n                     :else\n                     (let [[rethrow-critical? s2]\n                           (case s2\n                             (:all     :any)              (if cljs? [false  :default] [false `Throwable])\n                             (:default :all-but-critical) (if cljs? [false  :default] [true  `Throwable])\n                             (:common)                    (if cljs? [false 'js/Error] [false `Exception])\n                             (:ex-info)\n                             (if cljs?\n                               [false    'cljs.core.ExceptionInfo]\n                               [false 'clojure.lang.ExceptionInfo])\n\n                             (throw\n                               (ex-info \"Unexpected Truss `try*` catch clause keyword\"\n                                 {:given    {:value s2, :type (type s2)}\n                                  :expected '#{:ex-info :common :all :default}})))]\n\n                       (if rethrow-critical?\n                         `(catch ~s2 ~s3 (throw-critical ~s3) ~@more)\n                         `(catch ~s2 ~s3                      ~@more)))))))\n             forms)]\n\n       `(try ~@forms))))\n\n(comment\n  (macroexpand '(try*         (catch :all     t t 1 2 3) (finally 1 2 3)))\n  (macroexpand '(try* (/ 1 0) (catch :all     t t 1 2 3) (finally 1 2 3)))\n  (macroexpand '(try* (/ 1 0) (catch :default t t 1 2 3) (finally 1 2 3))))\n\n#?(:clj\n   (defmacro catching\n     \"Terse cross-platform util to swallow exceptions in `expr`.\n     Like (try* expr (catch :default _ nil)). See also `try*`.\"\n     ([            expr] `(try* ~expr (catch :default     ~'_)))\n     ([catch-class expr] `(try* ~expr (catch ~catch-class ~'_)))))\n\n(comment (catching (zero? \"9\")))\n\n(defn unexpected-arg!\n  \"Throws `truss/ex-info` to indicate an unexpected argument.\n  Takes optional kvs for merging into exception's data map.\n\n    (let [mode :unexpected]\n      (case mode\n        :read  (do <...>)\n        :write (do <...>)\n        (unexpected-arg! mode\n          {:param       'mode\n           :context  `my-function\n           :expected #{:read :write}}))) =>\n\n    Unexpected argument: :unexpected\n    {:param 'mode,\n     :arg {:value :unexpected, :type clojure.lang.Keyword},\n     :context 'taoensso.encore/my-function,\n     :expected #{:read :write}}\"\n\n  {:arglists\n   '([arg]\n     [arg   {:keys [msg context param expected ...]}]\n     [arg & {:keys [msg context param expected ...]}])}\n\n  ([arg     ] (unexpected-arg! arg nil))\n  ([arg opts]\n   (throw\n     (ex-info (or (get opts :msg) (str \"Unexpected argument: \" (if (nil? arg) \"<nil>\" arg)))\n       (conj {:arg (typed-val arg)} (dissoc opts :msg)))))\n\n  ([arg k1 v1                  ] (unexpected-arg! arg {k1 v1}))\n  ([arg k1 v1 k2 v2            ] (unexpected-arg! arg {k1 v1, k2 v2}))\n  ([arg k1 v1 k2 v2 k3 v3      ] (unexpected-arg! arg {k1 v1, k2 v2, k3 v3}))\n  ([arg k1 v1 k2 v2 k3 v3 k4 v4] (unexpected-arg! arg {k1 v1, k2 v2, k3 v3, k4 v4})))\n\n(comment (unexpected-arg! :arg :expected '#{string?}))\n\n(defn matching-error\n  \"Given a platform error and criteria for matching, returns the error if it\n  matches all criteria. Otherwise returns nil.\n\n  `kind` may be:\n    - A class (`ArithmeticException`, `AssertionError`, etc.)\n    - A special keyword as given to `try*` (`:default`, `:common`, `:ex-info`, `:all`)\n    - A set of `kind`s  as above, at least one of which must match\n    - A predicate function, (fn match? [x]) -> bool\n\n  `pattern` may be:\n    - A string or Regex against which `ex-message` must match\n    - A map             against which `ex-data`    must match using `submap?`\n    - A set of `pattern`s as above, at least one of which must match\n\n  When an error with (nested) causes doesn't match, a match will be attempted\n  against its (nested) causes.\n\n  This is a low-level util, see also `throws`, `throws?`.\"\n  ([     error] error)\n  ([kind error]\n   (when-let [match?\n              (cond\n                (keyword? kind)\n                (case     kind\n                  (:default :all-but-critical) #?(:clj (non-critical-throwable?               error) :cljs (some?                   error))\n                  (:common)                    #?(:clj (instance? Exception                   error) :cljs (instance? js/Error      error))\n                  (:ex-info)                   #?(:clj (instance? clojure.lang.IExceptionInfo error) :cljs (instance? ExceptionInfo error))\n                  (:all :any)                  #?(:clj (instance? Throwable                   error) :cljs (some?                   error))\n                  (throw\n                    (ex-info \"Unexpected Truss `matching-error` `kind` keyword\"\n                      {:given    (typed-val kind)\n                       :expected '#{:default :common :ex-info :all}})))\n\n                (error? kind) (= kind error) ; Exact match\n                (fn?    kind) (kind error)   ; Pred\n                (set?   kind) (impl/rsome #(matching-error % error) kind)\n                :else (instance? kind error))]\n     error))\n\n  ([kind pattern error]\n   (if-let [match?\n            (and\n              (matching-error kind error)\n              (cond\n                (nil?             pattern) true\n                (set?             pattern) (impl/rsome #(matching-error kind % error) pattern)\n                (string?          pattern) (impl/str-contains?     (ex-message error) pattern)\n                (impl/re-pattern? pattern) (re-find pattern        (ex-message error))\n                (map?             pattern) (when-let [data         (ex-data    error)]\n                                             (submap? data pattern))\n                :else\n                (unexpected-arg! pattern\n                  {:param       'pattern\n                   :context  `matching-error\n                   :expected '#{nil set string re-pattern map}})))]\n     error\n     ;; Try match cause\n     (when-let [cause (ex-cause error)]\n       (matching-error kind pattern cause)))))\n\n#?(:clj\n   (defmacro throws\n     \"Evals `form` and if it throws an error that matches given criteria using\n     `matching-error`, returns the matching error. Otherwise returns nil.\n\n     Useful for unit tests, e.g.:\n       (is (throws :default {:a :b}  (throw (ex-info \\\"MyEx\\\" {:a :b, :c :d})))) ; => ExceptionInfo\n       (is (throws :default \\\"MyEx\\\" (throw (ex-info \\\"MyEx\\\" {:a :b, :c :d})))) ; => ExceptionInfo\n\n     See also `throws?`, `matching-error`.\"\n     ([             form] `                               (try* ~form nil (catch :all ~'t ~'t)))\n     ([kind         form] `(matching-error ~kind          (try* ~form nil (catch :all ~'t ~'t))))\n     ([kind pattern form] `(matching-error ~kind ~pattern (try* ~form nil (catch :all ~'t ~'t))))))\n\n#?(:clj\n   (defmacro throws?\n     \"Evals `form` and if it throws an error that matches given criteria using\n     `matching-error`, returns true. Otherwise returns false.\n\n     Useful for unit tests, e.g.:\n       (is (throws? :default {:a :b}  (throw (ex-info \\\"MyEx\\\" {:a :b, :c :d})))) ; => true\n       (is (throws? :default \\\"MyEx\\\" (throw (ex-info \\\"MyEx\\\" {:a :b, :c :d})))) ; => true\n\n     See also `throws`, `matching-error`.\"\n     ([             form] `(boolean (throws                ~form)))\n     ([kind         form] `(boolean (throws ~kind          ~form)))\n     ([kind pattern form] `(boolean (throws ~kind ~pattern ~form)))))\n\n(let [get-default-error-fn\n      (fn [base-data]\n        (let [msg       (get    base-data :error/msg \"Error thrown during reduction\")\n              base-data (dissoc base-data :error/msg)]\n\n          (fn default-error-fn [data cause] ; == (partial ex-info <msg>)\n            (throw (ex-info msg (conj base-data data) cause)))))]\n\n  (defn catching-rf\n    \"Returns wrapper around given reducing function `rf` so that if `rf`\n    throws, (error-fn <thrown-error> <contextual-data>) will be called.\n\n    The default `error-fn` will rethrow the original error, wrapped in\n    extra contextual information to aid debugging.\n\n    Helps make reducing fns easier to debug!\n    See also `catching-xform`.\"\n    ([         rf] (catching-rf (get-default-error-fn {:rf rf}) rf))\n    ([error-fn rf]\n     (let [error-fn\n           (if (map? error-fn) ; Undocumented convenience\n             (get-default-error-fn error-fn)\n             (do                   error-fn))]\n\n       (fn catching-rf\n         ([       ] (try* (rf)        (catch :all t (error-fn {:rf rf :call '(rf)} t))))\n         ([acc    ] (try* (rf acc)    (catch :all t (error-fn {:rf rf :call '(rf acc)    :args {:acc (typed-val acc)}} t))))\n         ([acc in ] (try* (rf acc in) (catch :all t (error-fn {:rf rf :call '(rf acc in) :args {:acc (typed-val acc)\n                                                                                                :in  (typed-val in)}} t))))\n         ([acc k v]\n          (try* (rf acc k v)\n            (catch :all t\n              (error-fn\n                {:rf     rf\n                 :call '(rf acc k v)\n                 :args\n                 {:acc (typed-val acc)\n                  :k   (typed-val k)\n                  :v   (typed-val v)}}\n                t)))))))))\n\n(defn catching-xform\n  \"Like `catching-rf`, but applies to a transducer (`xform`).\n\n  Helps make transductions much easier to debug by greatly improving\n  the info provided in any errors thrown by `xform` or the reducing fn:\n\n    (transduce\n      (catching-xform (comp (filter even?) (map inc))) ; Modified xform\n      <reducing-fn>\n      <...>)\"\n\n  ([error-fn xform] (comp (fn [rf] (catching-rf error-fn rf)) xform))\n  ([         xform] (comp           catching-rf               xform)))\n\n;;;; Assertions\n\n(let [newline #?(:cljs \"\\n\" :clj (System/getProperty \"line.separator\"))\n      legacy-ex-data? (impl/legacy-assertion-ex-data?)]\n\n  (defn failed-assertion-ex-info\n    \"Returns an appropriate `truss/ex-info` for given failed assertion info map.\"\n    ([                failed-assertion-info] (failed-assertion-ex-info legacy-ex-data? failed-assertion-info))\n    ([legacy-ex-data? failed-assertion-info]\n     (let [{:keys [inst ns coords, pred arg-form arg-val, data error]} failed-assertion-info\n           undefined-arg? (impl/identical-kw? arg-val :truss/exception)\n\n           coords-str ; Faster (str coords)\n           (when-let [[line column] coords]\n             (if column\n               (str \"[\" line \",\" column \"]\")\n               (str \"[\" line \"]\")))\n\n           msg (str \"Truss assertion failed at \" ns coords-str \": \" (list pred arg-form))\n           msg\n           (if error\n             (let [error-msg (ex-message error)]\n               (if undefined-arg?\n                 (str msg newline \"Error evaluating arg: \"  error-msg)\n                 (str msg newline \"Error evaluating pred: \" error-msg)))\n             msg)]\n\n       (ex-info msg\n\n         (if legacy-ex-data?\n           {:dt     (impl/now-dt*)\n            :loc    (let [[line column] coords] {:ns ns, :line line, :column column})\n            :msg    msg\n            :pred   pred\n            :data   {:arg data, :dynamic *ctx*}\n            :env    {:*assert* *assert*}\n            :error  error\n            :arg\n            {:form  arg-form\n             :value arg-val\n             :type  (if undefined-arg? :truss/exception (type arg-val))}}\n\n           (impl/assoc-some\n             {:inst   (impl/now-inst*)\n              :ns     ns\n              :pred   pred\n              :arg\n              {:form  arg-form\n               :value arg-val\n               :type  (if undefined-arg? :truss/exception (type arg-val))}}\n             {:coords coords\n              :data   data}))\n\n         error)))))\n\n(def ^:dynamic *failed-assertion-handler*\n  \"?(fn [failed-assertion-info]) to call with failed assertion info map\n  when a Truss assertion (`have`, `have?`, `have!`, `have!?`) fails.\n\n  Will by default throw an appropriate `truss/ex-info`.\n  This is a decent place to inject logging for assertion failures.\"\n  (fn  [failed-assertion-info]\n    (-> failed-assertion-info failed-assertion-ex-info throw)))\n\n(defn ^:no-doc failed-assertion!\n  \"Private, don't use.\"\n  [ns line column, pred arg-form arg-val, data-fn error]\n  (if-let [;; Not accessible from impl ns in Cljs\n           handler *failed-assertion-handler*]\n    (handler\n      (let [undefined-arg? (instance? ArgEvalError arg-val)]\n        (FailedAssertionInfo. ns\n          (when line (if column [line column] [line]))\n          pred arg-form\n          (if undefined-arg? :truss/exception arg-val)\n          (when-let [df data-fn] (impl/catching (df) _ :truss/exception))\n          (cond\n            (identical? error impl/FalsePredError) nil\n            undefined-arg? (.-ex ^ArgEvalError error)\n            :else                              error))))\n    arg-val))\n\n#?(:clj\n   (defmacro have\n     \"Main Truss assertion util.\n     Takes a (fn pred [x]) => truthy, and >=1 vals.\n     Tests pred against each val,trapping errors.\n\n     If any pred test fails, throws a detailed `truss/ex-info`.\n     Otherwise returns input val/s for convenient inline-use/binding.\n\n     Respects `*assert*`, so tests can be elided from production if desired\n     (meaning zero runtime cost).\n\n     Examples:\n       (defn my-trim [x] (str/trim (have string? x)))\n\n       ;; Add arb optional info to thrown ex-data using `:data`:\n       (have string? \\\"foo\\\" :data {:user-id 101}) => \\\"foo\\\"\n\n       ;; Assert inside collections using `:in`:\n       (have string? :in #{\\\"foo\\\" \\\"bar\\\"}) => #{\\\"foo\\\" \\\"bar\\\"}\n\n     Regarding use within other macros:\n       Due to CLJ-865, callsite info like line number of outer macro\n       will be lost. See `keep-callsite` for workaround.\n\n     See also `have?`, `have!`.\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(impl/assert-args true false ~(callsite-coords &form) ~args)))\n\n#?(:clj\n   (defmacro have?\n     \"Truss assertion util.\n     Like `have` but returns `true` (rather than given arg value) on success.\n     Handy for `:pre`/`:post` conditions. Compare:\n       ((fn my-fn [] {:post [(have  nil? %)]} nil)) ; {:post [nil ]} FAILS\n       ((fn my-fn [] {:post [(have? nil? %)]} nil)) ; {:post [true]} passes as intended\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(impl/assert-args true true ~(callsite-coords &form) ~args)))\n\n#?(:clj\n   (defmacro have!\n     \"Truss assertion util.\n     Like `have` but ignores `*assert*` value (so will never be elided).\n     Useful for important conditions in production (e.g. security checks).\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(impl/assert-args false false ~(callsite-coords &form) ~args)))\n\n#?(:clj\n   (defmacro have!?\n     \"Truss assertion util.\n     Returns `true` (rather than given arg value) on success, and ignores\n     `*assert*` value (so will never be elided).\n  \n     **WARNING**: do NOT use in `:pre`/`:post` conditions since those ALWAYS\n     respect `*assert*`, contradicting the intention of the bang (`!`) here.\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(impl/assert-args false true ~(callsite-coords &form) ~args)))\n\n;;;; Deprecated\n\n(defn ^:no-doc ^:deprecated get-dynamic-assertion-data [] *ctx*)\n(defn ^:no-doc ^:deprecated get-data                   [] *ctx*)\n(defn ^:no-doc ^:deprecated set-error-fn! [f]\n  #?(:cljs (set!           *failed-assertion-handler*         f)\n     :clj  (alter-var-root *failed-assertion-handler* (fn [_] f))))\n\n#?(:clj (defmacro ^:no-doc ^:deprecated with-dynamic-assertion-data [data & body] `(binding [*ctx* ~data] ~@body)))\n#?(:clj (defmacro ^:no-doc ^:deprecated with-data                   [data & body] `(binding [*ctx* ~data] ~@body)))\n#?(:clj (defmacro ^:no-doc ^:deprecated with-error-fn               [f    & body] `(binding [*failed-assertion-handler* ~f] ~@body)))\n"],"x_google_ignoreList":[0]}