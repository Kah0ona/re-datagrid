{"version":3,"sources":["schema/spec/core.cljc"],"mappings":"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","names":["schema$spec$core$CoreSpec$subschemas$dyn","x__5373__auto__","m__5374__auto__","schema.spec.core/subschemas","goog/typeOf","m__5372__auto__","cljs.core/missing-protocol","schema$spec$core$CoreSpec$checker$dyn","schema.spec.core/checker","schema.spec.core/CoreSpec","this","params","schema.spec.core/+no-precondition+","_","schema.spec.core/precondition","s","p","err-f","x","temp__5823__auto__","reason","e47492","js/Object","e#","schema.utils/error","schema.utils/make-ValidationError","cljs.core/Delay","G__47494","schema.utils/value-name","schema.spec.core/run-checker","f","return-walked?","G__47499","G__47500","cljs.core.atom","schema.spec.core/with-cache","cache","cache-key","wrap-recursive-delay","result-fn","temp__5821__auto__","w","fexpr__47501","cljs.core/deref","cljs.core._EQ_","G__47502","fexpr__47503","cljs.core.swap_BANG_","cljs.core/assoc","res","p__47504","p__47505","map__47506","cljs.core/--destructure-map","cljs.core.get","map__47507","schema.spec.core/sub-checker","schema","error-wrap","subschema-checker","sub","d","fexpr__47508","e","schema.utils/error-val"],"sourcesContent":["(ns schema.spec.core\n  \"Protocol and preliminaries for Schema 'specs', which are a common language\n   for schemas to use to express their structure.\"\n  (:require\n   #?(:clj [schema.macros :as macros])\n   [schema.utils :as utils])\n  #?(:cljs (:require-macros [schema.macros :as macros])))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Core spec protocol\n\n(defprotocol CoreSpec\n  \"Specs are a common language for Schemas to express their structure.\n   These two use-cases aren't privileged, just the two that are considered core\n   to being a Spec.\"\n  (subschemas [this]\n    \"List all subschemas\")\n  (checker [this params]\n    \"Create a function that takes [data], and either returns a walked version of data\n     (by default, usually just data), or a utils/ErrorContainer containing value that looks\n     like the 'bad' parts of data with ValidationErrors at the leaves describing the failures.\n\n     params is a map specifying:\n      - :subschema-checker - a function for checking subschemas\n      - :returned-walked? - a boolean specifying whether to return a walked version of the data\n        (otherwise, nil is returned which increases performance)\n      - :cache - a map structure from schema to checker, which speeds up checker creation\n        when the same subschema appears multiple times, and also facilitates handling\n        recursive schemas.\"))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Preconditions\n\n;; A Precondition is a function of a value that returns a\n;; ValidationError if the value does not satisfy the precondition,\n;; and otherwise returns nil.\n;; e.g., (s/defschema Precondition (s/=> (s/maybe schema.utils.ValidationError) s/Any))\n;; as such, a precondition is essentially a very simple checker.\n\n(def +no-precondition+ (fn [_] nil))\n\n(defn precondition\n  \"Helper for making preconditions.\n   Takes a schema, predicate p, and error function err-f.\n   If the datum passes the predicate, returns nil.\n   Otherwise, returns a validation error with description (err-f datum-description),\n   where datum-description is a (short) printable stand-in for the datum.\"\n  [s p err-f]\n  (fn [x]\n    (when-let [reason (macros/try-catchall (when-not (p x) 'not) (catch e# 'throws?))]\n      (macros/validation-error s x (err-f (utils/value-name x)) reason))))\n\n#?(:clj\n(defmacro simple-precondition\n  \"A simple precondition where f-sym names a predicate (e.g. (simple-precondition s map?))\"\n  [s f-sym]\n  `(precondition ~s ~f-sym #(list (quote ~f-sym) %))))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Helpers\n\n(defn run-checker\n  \"A helper to start a checking run, by setting the appropriate params.\n   For examples, see schema.core/checker or schema.coerce/coercer.\"\n  [f return-walked? s]\n  (f\n   s\n   {:subschema-checker f\n    :return-walked? return-walked?\n    :cache #?(:clj (java.util.IdentityHashMap.) :cljs (atom {}))}))\n\n(defn with-cache [cache cache-key wrap-recursive-delay result-fn]\n  (if-let [w #?(:clj (.get ^java.util.Map cache cache-key)\n                :cljs (@cache cache-key))]\n    (if (= ::in-progress w) ;; recursive\n      (wrap-recursive-delay (delay #?(:clj (.get ^java.util.Map cache cache-key)\n                                      :cljs (@cache cache-key))))\n      w)\n    (do #?(:clj (.put ^java.util.Map cache cache-key ::in-progress)\n           :cljs (swap! cache assoc cache-key ::in-progress))\n        (let [res (result-fn)]\n          #?(:clj (.put ^java.util.Map cache cache-key res)\n             :cljs (swap! cache assoc cache-key res))\n          res))))\n\n(defn sub-checker\n  \"Should be called recursively on each subschema in the 'checker' method of a spec.\n   Handles caching and error wrapping behavior.\"\n  [{:keys [schema error-wrap]}\n   {:keys [subschema-checker cache] :as params}]\n  (let [sub (with-cache cache schema\n              (fn [d] (fn [x] (@d x)))\n              (fn [] (subschema-checker schema params)))]\n    (if error-wrap\n      (fn [x]\n        (let [res (sub x)]\n          (if-let [e (utils/error-val res)]\n            (utils/error (error-wrap res))\n            res)))\n      sub)))\n"],"x_google_ignoreList":[0]}