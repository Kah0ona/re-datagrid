shadow$provide.module$node_modules$scheduler$cjs$scheduler_development = function(global, require, module, exports) {
  (function() {
    function push(heap, node) {
      var index = heap.length;
      heap.push(node);
      a: {
        for (; index > 0;) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (compare(parent, node) > 0) {
            heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
          } else {
            break a;
          }
        }
      }
    }
    function peek(heap) {
      return heap.length === 0 ? null : heap[0];
    }
    function pop(heap) {
      if (heap.length === 0) {
        return null;
      }
      var first = heap[0], last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a: {
          for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength;) {
            var leftIndex = (index + 1) * 2 - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (compare(left, last) < 0) {
              rightIndex < length && compare(right, left) < 0 ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
            } else if (rightIndex < length && compare(right, last) < 0) {
              heap[index] = right, heap[rightIndex] = last, index = rightIndex;
            } else {
              break a;
            }
          }
        }
      }
      return first;
    }
    function compare(a, b) {
      var diff = a.sortIndex - b.sortIndex;
      return diff !== 0 ? diff : a.id - b.id;
    }
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); timer !== null;) {
        if (timer.callback === null) {
          pop(timerQueue);
        } else if (timer.startTime <= currentTime) {
          pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
        } else {
          break;
        }
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = !1;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled) {
        if (peek(taskQueue) !== null) {
          isHostCallbackScheduled = !0, requestHostCallback(flushWork);
        } else {
          var firstTimer = peek(timerQueue);
          firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
      }
    }
    function flushWork(hasTimeRemaining, initialTime) {
      isHostCallbackScheduled = !1;
      isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
      isPerformingWork = !0;
      var previousPriorityLevel = currentPriorityLevel;
      try {
        advanceTimers(initialTime);
        for (currentTask = peek(taskQueue); currentTask !== null && (!(currentTask.expirationTime > initialTime) || hasTimeRemaining && !shouldYieldToHost());) {
          var callback = currentTask.callback;
          if (typeof callback === "function") {
            currentTask.callback = null;
            currentPriorityLevel = currentTask.priorityLevel;
            var continuationCallback = callback(currentTask.expirationTime <= initialTime);
            initialTime = exports.unstable_now();
            typeof continuationCallback === "function" ? currentTask.callback = continuationCallback : currentTask === peek(taskQueue) && pop(taskQueue);
            advanceTimers(initialTime);
          } else {
            pop(taskQueue);
          }
          currentTask = peek(taskQueue);
        }
        if (currentTask !== null) {
          var JSCompiler_inline_result = !0;
        } else {
          var firstTimer = peek(timerQueue);
          firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - initialTime);
          JSCompiler_inline_result = !1;
        }
        return JSCompiler_inline_result;
      } finally {
        currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
      }
    }
    function shouldYieldToHost() {
      return exports.unstable_now() - startTime < frameInterval ? !1 : !0;
    }
    function requestHostCallback(callback) {
      scheduledHostCallback = callback;
      isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline());
    }
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function() {
        callback(exports.unstable_now());
      }, ms);
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    if (typeof performance === "object" && typeof performance.now === "function") {
      var localPerformance = performance;
      exports.unstable_now = function() {
        return localPerformance.now();
      };
    } else {
      var localDate = Date, initialTime = localDate.now();
      exports.unstable_now = function() {
        return localDate.now() - initialTime;
      };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = !1, isHostCallbackScheduled = !1, isHostTimeoutScheduled = !1, localSetTimeout = typeof setTimeout === "function" ? setTimeout : null, localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null, localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
    typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    var isMessageLoopRunning = !1, scheduledHostCallback = null, taskTimeoutID = -1, frameInterval = 5, startTime = -1, performWorkUntilDeadline = function() {
      if (scheduledHostCallback !== null) {
        var currentTime = exports.unstable_now();
        startTime = currentTime;
        var hasMoreWork = !0;
        try {
          hasMoreWork = scheduledHostCallback(!0, currentTime);
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : (isMessageLoopRunning = !1, scheduledHostCallback = null);
        }
      } else {
        isMessageLoopRunning = !1;
      }
    };
    if (typeof localSetImmediate === "function") {
      var schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline);
      };
    } else if (typeof MessageChannel !== "undefined") {
      var channel = new MessageChannel(), port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function() {
        port.postMessage(null);
      };
    } else {
      schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0);
      };
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
      task.callback = null;
    };
    exports.unstable_continueExecution = function() {
      isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback(flushWork));
    };
    exports.unstable_forceFrameRate = function(fps) {
      fps < 0 || fps > 125 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = fps > 0 ? Math.floor(1000 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return currentPriorityLevel;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return peek(taskQueue);
    };
    exports.unstable_next = function(eventHandler) {
      switch(currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
      switch(priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
      var currentTime = exports.unstable_now();
      typeof options === "object" && options !== null ? (options = options.delay, options = typeof options === "number" && options > 0 ? currentTime + options : currentTime) : options = currentTime;
      switch(priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 10000;
          break;
        default:
          timeout = 5000;
      }
      timeout = options + timeout;
      priorityLevel = {id:taskIdCounter++, callback, priorityLevel, startTime:options, expirationTime:timeout, sortIndex:-1};
      options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), peek(taskQueue) === null && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback(flushWork)));
      return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function() {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
};

//# sourceMappingURL=module$node_modules$scheduler$cjs$scheduler_development.js.map
