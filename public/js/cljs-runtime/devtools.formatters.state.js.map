{"version":3,"sources":["devtools/formatters/state.cljs"],"mappings":"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","names":["devtools.formatters.state/*current-state*","devtools.formatters.state/valid-current-state?","devtools.formatters.state/get-default-state","js/Error","devtools.formatters.state/get-current-state","var_args","args__5732__auto__","len__5726__auto__","i__5727__auto__","argseq__5733__auto__","cljs.core/IndexedSeq","devtools.formatters.state/update-current-state!","seq29974","G__29975","cljs.core/first","cljs.core/next","self__5711__auto__","f","args","cljs.core.apply","devtools.formatters.state/push-object-to-current-history!","object","devtools.formatters.state.update_current_state_BANG_","cljs.core/update","cljs.core/conj","devtools.formatters.state/get-current-history","devtools.formatters.state/is-circular?","history","p1__29988#","cljs.core/some","devtools.formatters.state/get-last-object-from-current-history","devtools.formatters.state/get-second-last-object-from-current-history","cljs.core/second","devtools.formatters.state/present-path-segment","v","cljs.core/Keyword","devtools.formatters.state/seek-path-segment","p__29992","vec__29993","cljs.core.nth","seq29989","G__29990","G__29991","coll","val","seq'd-map?","*","p__29996","vec__29997","k","and__5000__auto__","devtools.formatters.state/build-path-segment","parent-object","cljs.core/map?","devtools.formatters.state.seek_path_segment","cljs.core/seq","cljs.core/sequential?","cljs.core.map_indexed","i","x","cljs.core/set?","cljs.core/contains?","cljs.core/integer?","devtools.formatters.state/mapping?","obj","first-kw","cljs.core/vector?","valid-kw?","cljs.core._EQ_","cljs.core/count","devtools.formatters.state/ignore-path-in-fake-vector","path","or__5002__auto__","devtools.formatters.state/find-path-in-fake-vector","second-last-history","cljs.core.conj","devtools.formatters.state/find-path","path-segment","devtools.formatters.state/extend-path-info","path-info","devtools.formatters.state/add-object-to-current-path-info!","devtools.formatters.state/get-current-path-info","devtools.formatters.state/prevent-recursion?","cljs.core/boolean","devtools.formatters.state/set-prevent-recursion","state","cljs.core.assoc","cljs.core.dissoc","devtools.formatters.state/get-managed-print-level","devtools.formatters.state/set-managed-print-level","devtools.formatters.state/get-depth-budget","devtools.formatters.state/set-depth-budget","devtools.formatters.state/reset-depth-limits"],"sourcesContent":["(ns devtools.formatters.state)\n\n; - state management --------------------------------------------------------------------------------------------------------\n;\n; we have to maintain some state:\n; a) to prevent infinite recursion in some pathological cases (https://github.com/binaryage/cljs-devtools/issues/2)\n; b) to keep track of printed objects to visually signal circular data structures\n;\n; We dynamically bind *current-config* to the config passed from \"outside\" when entering calls to our API methods.\n; Initially the state is empty, but we accumulate there a history of seen values when rendering individual values\n; in depth-first traversal order. See alt-printer-impl where we re-bind *current-config* for each traversal level.\n; But there is a catch. For larger data structures our printing methods usually do not print everything at once.\n; We can include so called \"object references\" which are just placeholders which can be expanded later\n; by DevTools UI (when user clicks a disclosure triangle).\n; For proper continuation in rendering of those references we have to carry our existing state over.\n; We use \"config\" feature of custom formatters system to pass current state to future API calls.\n\n(def ^:dynamic *current-state* nil)\n\n(defn valid-current-state? []\n  (some? *current-state*))\n\n(defn get-default-state []\n  {})\n\n(defn get-current-state []\n  {:pre [(valid-current-state?)]}\n  *current-state*)\n\n(defn update-current-state! [f & args]\n  {:pre [(valid-current-state?)]}\n  (set! *current-state* (apply f *current-state* args)))\n\n; -- high level API ---------------------------------------------------------------------------------------------------------\n\n(defn push-object-to-current-history! [object]\n  (update-current-state! update :history conj object))\n\n(defn get-current-history []\n  (:history (get-current-state)))\n\n(defn is-circular? [object]\n  (let [history (get-current-history)]\n    (some #(identical? % object) history)))\n\n(defn get-last-object-from-current-history []\n  (first (get-current-history)))                                                                                              ; note the list is reversed\n\n(defn get-second-last-object-from-current-history []\n  (second (get-current-history)))                                                                                              ; note the list is reversed\n\n(defn present-path-segment [v]\n  (cond\n    (string? v) v\n    ;; we'd like to preserve keywords for easy get\n    (keyword? v) v\n    (number? v) v\n    :else \"?\"))\n\n(defn seek-path-segment [coll val & [seq'd-map?]]\n  (let [* (fn [[k v]]\n            (cond\n              ;; we need to know the paths for keywords, these are clickable\n              (and seq'd-map? (identical? k val))\n              (present-path-segment k)\n\n              (identical? v val)\n              (present-path-segment k)))]\n    (some * coll)))\n\n(defn build-path-segment [parent-object object]\n  (cond\n    (map? parent-object)                   (seek-path-segment (seq parent-object) object true)\n    (sequential? parent-object)            (seek-path-segment (map-indexed (fn [i x] [i x]) parent-object) object)\n    (and (set? parent-object)\n         (contains? parent-object object)\n         (or (string? object)\n             (keyword? object)\n             (integer? object)))           object           ;; if set has the simple object, return the object instead.\n    (and (set? parent-object)                               ;; in composite objects in sets, return the index in the set.\n         (contains? parent-object object)) (seek-path-segment (map-indexed (fn [i x] [i x]) parent-object) object)))\n\n;; This function checks a unique situation of looping an immediate child element `obj` of a parent element `history`\n;; say we have a general map {:a 2 :b {:gh 45} :c 4}\n;; and we call devtools.formatters.core/body-api-call with the map, the map ends up in\n;; devtools.formatters.markup/<details> which then calls devtools.formatters.markup/body-lines\n;; where the map will get seq'd resulting in ([:a 2] [:b {:gh 45}] [:c 4])\n;; these 3 vectors will then be pushed to history which will result in an issue when generating the path\n;; for example if we are looping over at `obj` as 2 and `history` as `[:a 2]` `build-path-segment` will return\n;; the path as 1 since the immediate history is a vector instead of a map.\n;; This function detects the condition that this is the case and then the next operation will be to\n;; get the first item in the vector which is the path.\n(defn mapping?\n  [history obj]\n  (let [first-kw (when (and (vector? obj)\n                            (map? history))\n                   (nth obj 0 nil))\n        valid-kw? (and first-kw\n                       (or (keyword? first-kw)\n                           (string? first-kw)\n                           (number? first-kw))\n                       ;; intentionally delaying realizing the whole vector\n                       (= (count obj) 2))]\n    (when valid-kw?\n      (contains? history first-kw))))\n\n(defn ignore-path-in-fake-vector\n  [history obj path]\n  ;; if the current item we are looping at is an artificial vector (explained at `mapping` above),\n  ;; don't append to the path\n  (when (mapping? history obj)\n    (or path [])))\n\n(defn find-path-in-fake-vector\n  [history path]\n  (let [second-last-history (get-second-last-object-from-current-history)]\n    ;; if the previous item is an artificial vector, lets append to the path info but take the first item\n    ;; in the artificial vector as the path. (Explained in `mapping` above)\n    (when (mapping? second-last-history history)\n      (conj (or path []) (nth history 0 nil)))))\n\n(defn find-path\n  [history obj path]\n  (let [path-segment (build-path-segment history obj)]\n    (when (some? path-segment)\n      (conj (or path []) path-segment))))\n\n(defn extend-path-info [path-info object]\n  (let [parent-object (get-last-object-from-current-history)]\n    (or (ignore-path-in-fake-vector parent-object object path-info)\n        (find-path-in-fake-vector parent-object path-info)\n        (find-path parent-object object path-info)\n        path-info)))\n\n(defn add-object-to-current-path-info! [object]\n  (update-current-state! update :path-info extend-path-info object))\n\n(defn get-current-path-info []\n  (:path-info (get-current-state)))\n\n(defn ^bool prevent-recursion? []\n  (boolean (:prevent-recursion (get-current-state))))\n\n(defn set-prevent-recursion [state val]\n  (if (some? val)\n    (assoc state :prevent-recursion val)\n    (dissoc state :prevent-recursion)))\n\n(defn get-managed-print-level []\n  (:managed-print-level (get-current-state)))\n\n(defn set-managed-print-level [state val]\n  (if (some? val)\n    (assoc state :managed-print-level val)\n    (dissoc state :managed-print-level)))\n\n(defn get-depth-budget []\n  (:depth-budget (get-current-state)))\n\n(defn set-depth-budget [state val]\n  (if (some? val)\n    (assoc state :depth-budget val)\n    (dissoc state :depth-budget)))\n\n(defn reset-depth-limits [state]\n  (-> state\n      (set-depth-budget nil)\n      (set-managed-print-level nil)))\n"],"x_google_ignoreList":[0]}